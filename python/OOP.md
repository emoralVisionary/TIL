# 객체 지향 프로그래밍

## 객체

> 객체란 무엇인가...? 세상에 존재하는 그 모든 것이다... 실존하는 무언가
>
> **파이썬의 모든 것은 객체이다.**
>
> 조정제, 버질 아블로, ... 은 실존한다. 그렇다면 _사람_ 이라는 것은 실존하는 것인가...? <br>1, 2, 3, ... 은 실존한다. 그렇다면 _정수_ 하는 것은 실존하는가...? <br>실존하는 것과 추상 개념 사이에는 분명한 차이가 있다. 
>
> `a = 'JOZE'` 를 실행하면, `a` 는 `'JOZE'` 라는 값을 가지면서 실존하게 될 것이다. 결국 우리가 **값** 이라고 불렀던, 부를 수 있는 그 모든 것은 **객체** 이다. **컴퓨터 저장 공간 (메모리)에 올라가있는, 할당된 실체!**
>
> 모든 정수끼리는 더할 수 있다. 하지만 alphabet 과 정수를 더하는 행위는 일반적으로 정의되어 있지 않으며, 시행할 수 없다! 즉, 추상 개념과 관련된 행동들은 정의되어 있거나 우리가 그것들을 생각할 수 있다. 
>
> 내가 짜는 프로그램에서는 내가 신이다. 클래스를 정의하겠다... 는 말은 내가 신의 역할을 하겠다는 것이다! _메타 클래스 (`type`)은 절대 신에 비유할 수 있다._
>
> 클래스가 있어야만 객체가 만들어지지만, 결국 Software 라는 것은 객체끼리 상호작용하는 것이 그 본질이자 핵심이다. 
>
> 일이 우선하고 객체가 일에 포함되는 `일(객체, 객체, ...)` 사상: 함수형 프로그래밍<br>`객체.일()` 일을 객체에 포함시켜버린 메타/사상, 객체를 최우선: 객체 지향 프로그래밍
>
> 함수 밖에 없는 세상에서는 코딩을 어떻게 했을까/할까... 를 한 번 생각해봐라.

 OOP 에서 객체는 클래스의 인스턴스이며, 클래스는 _Blueprint_ 역할을 한다고 볼 수 있다. 

 __* Object 는 관념적, Instance 는 실물적인 것 (실체, 사례) 라고 생각해도 되는가?__

**''인스턴스는 무엇의 실체/사례 이다'' 에서 무엇이 없으면 말이 안된다.**

**`my_lower('Hi')` ~ `'Hi'.lower()`** <br>
**`sorted([3, 1, 2])` ~ `[3, 1, 2].sort()`**

함수가 데이터 (객체)를 ~ 데이터 (객체)가 메서드를 호출

> _**객체 (Object)**_ 는 특정 타입의 _**인스턴스 (instance)**_ 이다. 

- 123, 900, 5 는 모두 `int` 의 인스턴스
- 'hello', 'bye' 는 모두 `string` 의 인스턴스
- [232, 89, 1], `[]` 는 모두 `list` 의 인스턴스 

### 객체 (Object) 의 특징

- 타입 (type): 어떤 연산자 (Operator)와 조작 (Method)가 가능한가?
- 속성 (attribute): 어떤 상태 (데이터)를 가지는가?
- 조작법 (method): 어떤 행위 (함수)를 할 수 있는가?

### 관련 연산자 및 함수

#### `is` 연산자

* `is` 
    - 객체의 Identity 를 검사하는 연산자 
    - 동일한 **(identical)**
    - 두 변수가 동일한 객체를 가리키는 경우 _True_ 
* `==` 
    - 겉보기에, 값이 동일한 지를 판별/판단한다. 
    - 동등한 (equal)
    - 두 객체가 같아 **보이지만** 실제로 동일한 **대상/객체** 를 가리키고 있다고 확인해 준 것은 아니다.

#### `isinstance` 함수

### 속성 (attribute)과 메서드 

 속성은 객체의 상태/데이터

 메서드는 특정 객체가 시행할 수 있는 행위를 뜻하며, 일반적으로 해당 클래스 내에 정의된 함수이다. 

## 프로그래밍 패러다임과 객체 지향 프로그래밍

* 명령형 프로그래밍
    - 절차 지향 프로그래밍
    - 객체 지향 프로그래밍: 프로그램을 명령어의 목록으로 보는 시각에서 벗어나 여러 개의 독립된 단위로, 즉 **객체** 들의 모임으로 파악하고자 하는 것이다. 

### 객체 지향 프로그래밍

 객체 지향 프로그래밍은 결국 지극히 인간 중심적인 접근이자 사고방식이다. <br> 현실 세계를 프로그램 설계에 반영 **(추상화, abstraction!!)**

 `a = 1` 는 본질적으로 `a = int(1)` 와 완전히 동일하며 _**(literal)**_, 이미 우리는 인스턴스를 사용하고 있었다. `a` 는 객체인가...? => 그냥 이름이다. 하지만, `a` 가 지칭하는 대상 (= 1)은 객체이다! <br>_pythontutor_ 에서도 _frame (namespace)_ 와 _objects_ (객체 영역)을 분리하고 있다. 이름은 이름일 뿐이며, 객체 지향을 객체에 대한 것이다. 

### 클래스와 인스턴스 

```python
class MyClass:
    my_attribute = None
    
    def my_method():
        pass

my_instance = MyClass()
my_instance.my_attribute
my_instanve.my_method()
```

 클래스도 type 이 존재하며, 모든 클래스의 type 은 `type` 이다. 


 `type` 은 메타 클래스라고 불리우며, 모든 클래스의 클래스라고 할 수 있다. 절대 신

### 속성 (attribute), _속성 값_ ~ 결과

특정 {데이터 타입}/클래스의 객체들이 가지게 될 상태/데이터를 의미. <br>속성 정의는 꼭 생성자(__init__) 메서드에 작성해야 하지는 않지만, 일반적으로 생성자 메서드에 많이 작성합니다.

### 메서드 ~ 과정 

 행위, 일, 함수

 특정 {데이터 타입}/클래스의 객체에 공통적으로 적용 가능한 행위 (함수). 

결국 결과, 속성 값을 얻는 것이 컴퓨터의 존재 목적이겠지만, 속성 값 혼자서는 아무 것도 할 수 없다. 그 과정 때문에 프로그래밍, 프로그래머가 존재하는 것이다. 

### self

- 인스턴스 자기자신! 
- Class 자체의 존재 이유 top 1 => 인스턴스 생성!
- 클래스 내부에 정의된 함수들은 인스턴스를 위해서 만들어 놓은 것이다. 인스턴스가 할 행동, 일!
- 인스턴스 메서드를 정의하는 시점에는 인스턴스 자체가 존재하지 않는다. 태명 스웩.
- 파이썬에서 인스턴스 메서드는 무조건 self (인스턴스 자신)을 첫 번째 매개 변수/인자로 전달 받는다.
- **`'apple'.capitalize()` 의 실제 동작은 `str.capitalize('apple')` 라고 볼 수 있다. (축약형)**

### 생성자 (constructor) 와 소멸자 (destructor) 함수

 인스턴스 객체가 생성될 때 호출되는 메서드. 클래스명도 결국 변수명일 뿐이다. 

`()` 는 곧 **Call**, 호출이다. _**Call 은 어떤 의미를 지니는가...? 분기...?**_   

**데이터를 지우는/삭제하는/죽이는 방법** <br>1. `del` 호출 <br>2. 동일한 이름을 다른 변수에 할당. 

### 매직 메서드

`__` Double underscore 가 있는 메서드는 특수한 동작을 위해 만들어진 메서드이다. 우리가 직접 사용하는 경우는 생성자 정도...?<br>내가 하지 않았는데 있는 거니까 매직...?

실행되는 시점이나 trigger 가  다 정해져있다. 

**`__add__()`, `__gt__()`, etc... 결국 `+` 든 뭐든, 다 이미 메소드로 정의되어 있었기 때문에 사용가능했던 것이다. 다시 말하면, 이것 역시도 정의 가능하다. (오버라이딩 역시 가능하다.)**

## 클래스와 인스턴스

### 근본 논리 

클래스도 결국 객체로서 존재한다. (공장, 틀, 청사진 역시 실존한다.) 모든 객체는 속성과 메서드를 갖는다. 클래스 역시 속성과 메서드를 갖는다. 

메타 => 클래스 => 인스턴스 <br>인스턴스의 속성과 메서드는 클래스 내에 정의되어 있다. 그렇다면... 클래스의 속성과 메서드는 메타 클래스에 정의해야하나...? 말이 안 된다. 올라갈 수 없다. 메타 클래스를 뜯을 수는 없다. <br>**클래스 본인의 속성과 메서드도 클래스에 정의할 수 밖에 없다. ** 

클래스 속성과 클래스 메서드는 오롯이 클래스의 것인데... 그 하위 존재인 인스턴스에서도 접근 및 **수정**이 가능하다. (_cf. pythontutor_ ), **사실 수정은 일어나지 않는다.** <br>**Scope... 인스턴스 자기자신 => 클래스 메타로 생각하면 될 것 같다. **(LEGB 와 매우 유사하다!!)**

**모든 함수는 LEGB 순서에 따라서 _name_ 을 탐색한다!** (함수 내부에서 변수를 탐색할 때) <br>**인스턴스 내부에서는 self - class 순서로  _name_ 을 탐색한다** (인스턴스의 속성을 탐색할 때)

**인스턴스는 인스턴스 메서드 뿐만 아니라 static, 클래스 메서드에도 접근 가능하다. <br>하지만, _접근 가능하다 != 사용한다/사용해야 한다_ **

할 수 있긴 하지만, 그렇게 해서는 안되는 것이 많았다. **인스턴스에서 클래스 메서드와 스태틱 메서드는 호출하지 않는 것이 기본적인 사용법이다.**

※ _**왜 인스턴스를 클래스 변수에 대한 접근과 수정이 가능하도록 구현해놓은 것일까?**_ <br> =>  사실은 **클래스 변수가 수정/갱신된 것이 아니라!! 인스턴스 내부에 같은 이름의 인스턴스 변수가 생긴 것이다!!** <br> _name_ 탐색 순서는 _인스턴스 => 클래스_ 이므로 **클래스 변수가 동일한 이름의 인스턴스 변수에 의해 가려져 버린다.**


### 인스턴스 변수 

 인스턴스의 속성 

 각 인스턴스 고유의 속성


### 클래스 변수

 클래스 속성

 **모든 인스턴스가 공유**

 클래스 선언 내부에서 정의한다. 

 <classname>.<name> 으로 접근 및 할당 (다만, 인스턴스로 접근할 수 있긴 함)

#### **Scope... 인스턴스 자기자신 => 클래스 => 전역**


### 인스턴스와 클래스 간의 _namespace_

- 클래스를 정의하면 클래스와 그에 해당하는 이름 공간 생성


- 인스턴스를 만들면, 인스턴스 객체가 생성되고 독립적인 이름 공간 생성 (인스턴스 별로 이름 공간이 따로 있다)


- 인스턴스에서 특정 속성에 접근하면 인스턴스 => 클래스 순으로 탐색 (클래스 => 인스턴스 로의 순서는 불가)


### 메서드의 종류

* 인스턴스 메서드


* 클래스 메서드


* static method


#### 인스턴스 메서드 

 인스턴스가 사용할 메서드

 클래스 내부에 정의되는 메서드의 기본

 첫 번째 인자로 무조건 self 를 갖는다. 호출 시, 첫 번째 인자로 인스턴스 자기자신 (self)이 전달된다. 


#### 클래스 메서드 

 클래스가 사용할 메서드로, **호출 시에 첫 번째 인자로 클래스 (cls)가 전달된다.**  

 `@classmethod` 데코레이터를 사용하여 정의한다. 


#### 인스턴스 메서드와 클래스 메서드를 분리해놓은 이유는? and `self` 와 `cls` 는 무엇이 다른가...?

 클래스 자체의, 내부의 공통적인 변수, 속성들에 접근 및 변경 ~ 인스턴스가 따로, 개별적으로 값을 사용하기 위한 메서드


#### static method (정적 메서드) 

호출 시, `self` 나 `cls` 가 인자로 전달되지 않기 때문에 클래스 정보에 접근/수정이 불가하다. <br>일반 함수에 가깝다.


### 정리하는 예시

```python
class Puppy:
    population = 0
    
    def __init__(self, name, breed):
        self.name = name
        self.breed = breed
        Puppy.population += 1
        
    def __del__(self):
        Puppy.population -= 1
        
    @classmethod
    def get_population(cls):
        print(f'현재 강아지 마리수: {cls.population}')
        return cls.population
```

클래스 속성 및 메서드와 인스턴스 속성 및 메서드는 분명히 다르며 다르게 취급해야한다는 인식을 갖고 위의 코드를 분석, 이해해보자!



## 상속 

